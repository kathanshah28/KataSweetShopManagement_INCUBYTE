import unittest
import os
from dotenv import load_dotenv
from model.models import SweetShop # Assumes sweetshop.py is in the same directory
import pymongo

class TestSweetShop(unittest.TestCase):
    """
    Test suite for the Sweet Shop Management System, updated for MongoDB integration.
    """

    @classmethod
    def setUpClass(cls):
        """
        Load environment variables before any tests run.
        This points to a test-specific .env file.
        """
        load_dotenv('test.env')
        cls.connection_string = os.getenv("DB_CONNECTION_STRING")
        cls.db_name = os.getenv("DB_NAME")
        if not cls.connection_string or not cls.db_name:
            raise ValueError("DB_CONNECTION_STRING and DB_NAME must be set in test.env")

    def setUp(self):
        """
        Set up a new SweetShop instance and clear the test database before each test.
        This ensures test isolation.
        """
        self.shop = SweetShop(self.connection_string, self.db_name)
        # Clean up collections before each test
        self.shop.sweets_collection.delete_many({})
        self.shop.users_collection.delete_many({})

        # Pre-populate with sweets. The sweet_id is now a UUID generated by the method.
        self.shop.add_sweet("Kaju Katli", "Nut-Based", 50, 20)
        self.shop.add_sweet("Gajar Halwa", "Vegetable-Based", 30, 15)
        self.shop.add_sweet("Gulab Jamun", "Milk-Based", 10, 50)
        self.shop.add_sweet("Chocolate Bar", "Chocolate", 20, 100)
        
        # Register a test user
        self.test_user = "testuser"
        self.shop.register_user(self.test_user, "password")

    def tearDown(self):
        """
        Clean up resources after each test.
        """
        # In a more complex scenario with persistent connections, you might close them here.
        # For this class, the connection is managed internally.
        pass

    # --- User Management Tests ---
    def test_register_user(self):
        """Test that a new user can be registered."""
        self.shop.register_user("new_user", "new_pass")
        user = self.shop.users_collection.find_one({"username": "new_user"})
        self.assertIsNotNone(user)
        self.assertEqual(user['username'], "new_user")

    def test_register_duplicate_user(self):
        """Test that registering a user with a duplicate username fails."""
        with self.assertRaises(ValueError):
            self.shop.register_user(self.test_user, "another_password")

    # --- Core Sweet Operations Tests ---
    def test_add_sweet(self):
        """Test that a new sweet can be successfully added."""
        initial_count = self.shop.sweets_collection.count_documents({})
        self.shop.add_sweet("Jalebi", "Milk-Based", 25, 30)
        new_count = self.shop.sweets_collection.count_documents({})
        self.assertEqual(new_count, initial_count + 1)
        added_sweet = self.shop.sweets_collection.find_one({"name": "Jalebi"})
        self.assertIsNotNone(added_sweet)

    def test_delete_sweet(self):
        """Test that a sweet can be successfully removed."""
        sweet_to_delete = self.shop.sweets_collection.find_one({"name": "Kaju Katli"})
        self.assertIsNotNone(sweet_to_delete, "Prerequisite: Sweet should exist.")
        sweet_id = sweet_to_delete['sweet_id']
        
        initial_count = self.shop.sweets_collection.count_documents({})
        result = self.shop.delete_sweet(sweet_id)
        new_count = self.shop.sweets_collection.count_documents({})
        
        self.assertTrue(result)
        self.assertEqual(new_count, initial_count - 1)
        self.assertIsNone(self.shop.sweets_collection.find_one({"sweet_id": sweet_id}))

    def test_delete_non_existent_sweet(self):
        """Test that attempting to delete a sweet that does not exist fails."""
        with self.assertRaises(ValueError):
            self.shop.delete_sweet("non-existent-uuid")

    def test_view_all_sweets(self):
        """Test that all available sweets can be viewed."""
        sweets = self.shop.get_all_sweets()
        self.assertEqual(len(sweets), 4)

    # --- Search & Sort Tests ---
    def test_search_by_name(self):
        """Test searching for sweets by name."""
        results = self.shop.search_by_name("Kaju Katli")
        self.assertEqual(len(results), 1)
        self.assertEqual(results[0]['name'], "Kaju Katli")

    def test_sort_by_price(self):
        """Test sorting sweets by price in ascending order."""
        sorted_sweets = self.shop.sort_by('price')
        prices = [sweet['price'] for sweet in sorted_sweets]
        self.assertEqual(prices, [10, 20, 30, 50])

    # --- Inventory Management Tests ---
    def test_purchase_sweet_sufficient_stock(self):
        """Test purchasing a sweet when there is enough stock."""
        sweet_to_buy = self.shop.sweets_collection.find_one({"name": "Gulab Jamun"})
        sweet_id = sweet_to_buy['sweet_id']
        initial_quantity = sweet_to_buy['quantity']
        
        self.shop.purchase_sweet(self.test_user, sweet_id, 10)
        
        updated_sweet = self.shop.sweets_collection.find_one({"sweet_id": sweet_id})
        self.assertEqual(updated_sweet['quantity'], initial_quantity - 10)
        
        # Check purchase history
        history = self.shop.get_purchase_history(self.test_user)
        self.assertEqual(len(history), 1)
        self.assertEqual(history[0]['sweet_id'], sweet_id)
        self.assertEqual(history[0]['quantity'], 10)

    def test_purchase_sweet_insufficient_stock(self):
        """Test that purchasing a sweet raises an error if stock is insufficient."""
        sweet_to_buy = self.shop.sweets_collection.find_one({"name": "Gajar Halwa"})
        sweet_id = sweet_to_buy['sweet_id']
        with self.assertRaises(ValueError):
            self.shop.purchase_sweet(self.test_user, sweet_id, 100)

    def test_restock_sweet(self):
        """Test that restocking a sweet correctly increases its quantity."""
        sweet_to_restock = self.shop.sweets_collection.find_one({"name": "Kaju Katli"})
        sweet_id = sweet_to_restock['sweet_id']
        initial_quantity = sweet_to_restock['quantity']
        
        self.shop.restock_sweet(sweet_id, 50)
        
        updated_sweet = self.shop.sweets_collection.find_one({"sweet_id": sweet_id})
        self.assertEqual(updated_sweet['quantity'], initial_quantity + 50)

if __name__ == '__main__':
    unittest.main(argv=['first-arg-is-ignored'], exit=False)